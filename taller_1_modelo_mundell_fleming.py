# -*- coding: utf-8 -*-
"""Taller 1 modelo Mundell-Fleming

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17XtKYDJY0FJY8rYVYDZmJSZs1LZUsJd9

#Modelo Mundell-Fleming

##Curva IS
---

#Parametros:
* pendiente: Relación entre cambios en la tasa de interes y en el producto
* intercepto: Cuando la tasa de interes es 0
* multiplicador: Cambios en la demanda agregada
* tasa_interes: Tasa de interes actual
* producto: Nivel de producto actual

---

#Metodos

* calcular_tasa_interes_equilibrio:
  * objetivo: Encontrar la nueva tasa de interes dada una nueva cantidad de producto.
* desplazar_curva:
  * objetivo: Sumar un valor al atributo ***intercepto***, que permita generar el desplazamiento de la curva
"""

class CurvaIS:
    def __init__(self, pendiente, intercepto, multiplicador, tasa_interes, producto):
        self.pendiente = pendiente
        self.intercepto = intercepto
        self.multiplicador = multiplicador
        self.tasa_interes = tasa_interes
        self.producto = producto

    def calcular_tasa_interes_equilibrio(self, producto_nuevo):
        tasa_interes_nueva = (self.intercepto - producto_nuevo / self.multiplicador) / self.pendiente
        return tasa_interes_nueva

    def desplazar_curva(self, cambio_intercepto):
        self.intercepto += cambio_intercepto

"""#Curva LM
---

#Parametros:
* pendiente: Relación entre cambios en la tasa de interes y en el producto
* intercepto: Cuando la tasa de interes es 0
* oferta_monetaria:La cantidad total de dinero en la economía
* tasa_interes: Tasa de interés actual
* producto: Nivel actual de producto

---

#Metodos

* calcular_producto_equilibrio:
  * objetivo: Encontrar el nuevo nivel de producto en quilibrio dada una nueva tasa de interés.
* desplazar_curva:
  * objetivo: Sumar un valor al atributo ***oferta_monetaria***, que permita generar el desplazamiento de la curva
"""

class CurvaLM:
    def __init__(self, pendiente, intercepto, oferta_monetaria, tasa_interes, producto):
        self.pendiente = pendiente
        self.intercepto = intercepto
        self.oferta_monetaria = oferta_monetaria
        self.tasa_interes = tasa_interes
        self.producto = producto

    def calcular_producto_equilibrio(self, tasa_interes_nueva):
        producto_nuevo = (self.oferta_monetaria - self.intercepto - self.pendiente * tasa_interes_nueva) / self.pendiente
        return producto_nuevo

    def desplazar_curva(self, cambio_oferta_monetaria):
        self.oferta_monetaria += cambio_oferta_monetaria

"""#Curva BP
---

#Parametros:
* tasa_interes_mundial: Tasa de interés en los mercados internacionales.
* tipo_cambio: La relación entre la moneda local y la moneda extranjera.
* balanza_comercial:Exportaciones netas.
* flujo_capital: El flujo neto de capital hacia o desde el país

---

#Metodos

* calcular_tasa_interes_equilibrio:
  * objetivo: Dado el supuesto de perfecta movilidad de capitales, la tasa de interés local debe igualarse a la tasa de interés mundial para mantener el equilibrio en la balanza de pagos.
* desplazar_curva:
  * objetivo: Modifica el tipo de cambio.

* actualizar_tipo_cambio:
  * objetivo: Utiliza una fórmula simplificada para calcular un nuevo tipo de cambio en función de la tasa de interés de equilibrio en el mercado de bienes IS y el producto de equilibrio en el mercado monetario LM.  
"""

class CurvaBP:
    def __init__(self, tasa_interes_mundial, tipo_cambio, balanza_comercial, flujo_capital):
        self.tasa_interes_mundial = tasa_interes_mundial
        self.tipo_cambio = tipo_cambio
        self.balanza_comercial = balanza_comercial
        self.flujo_capital = flujo_capital

    def calcular_tasa_interes_equilibrio(self):
        # En el modelo Mundell-Fleming con perfecta movilidad de capitales, la tasa de interés doméstica
        # debe igualarse a la tasa de interés mundial para que haya equilibrio en la balanza de pagos.
        tasa_interes_equilibrio = self.tasa_interes_mundial
        return tasa_interes_equilibrio

    def desplazar_curva(self, tipo_cambio_nuevo):
        # Un cambio en el tipo de cambio afecta la balanza comercial, desplazando la curva BP.
        self.tipo_cambio += tipo_cambio_nuevo

    def actualizar_tipo_cambio(self, tasa_interes_is, producto_lm, tipo_cambio_actual):
        # Implementación simplificada para actualizar el tipo de cambio basado en el producto y la tasa de interés.
        tipo_cambio_nuevo = (tasa_interes_is - producto_lm / 1000) * 0.01
        return tipo_cambio_actual + tipo_cambio_nuevo

"""#Función de equilibrio
---

##1. Parametros:
* Se asignan valores iniciales para el producto, la tasa de interés y el tipo de cambio, tomando los valores de los objetos CurvaIS, CurvaLM y CurvaBP, respectivamente.

##2. Iteraciones:
* Se inicia un bucle que se ejecuta hasta un máximo de max_iteraciones veces o hasta que se encuentre una solución suficientemente precisa.

* Se actualiza el tipo de cambio utilizando la función actualizar_tipo_cambio, que depende de la tasa de interés y la producción calculadas.

* Se actualizan los valores iniciales del producto y la tasa de interés para la siguiente iteración.

##3. Retorno:
* Una vez encontrado el equilibrio o alcanzado el máximo número de iteraciones, se devuelven los valores finales del producto, tasa de interés y tipo de cambio.
"""

def encontrar_equilibrio(CurvaIS, CurvaLM, CurvaBP, max_iteraciones=100):
    producto_inicial = CurvaIS.producto
    tasa_interes_inicial = CurvaLM.tasa_interes
    tipo_cambio_inicial = CurvaBP.tipo_cambio

    for _ in range(max_iteraciones):
        tasa_interes_is = CurvaIS.calcular_tasa_interes_equilibrio(producto_inicial)
        producto_lm = CurvaLM.calcular_producto_equilibrio(tasa_interes_inicial)
        tasa_interes_bp = CurvaBP.calcular_tasa_interes_equilibrio()

        # Verificamos si las diferencias son muy pequeñas
        if abs(tasa_interes_is - tasa_interes_inicial) < 1e-10 and \
           abs(producto_lm - producto_inicial) < 1e-10 and \
           abs(tasa_interes_is - tasa_interes_bp) < 1e-10:
            break

        tipo_cambio_inicial = CurvaBP.actualizar_tipo_cambio(tasa_interes_is, producto_lm, tipo_cambio_inicial)

        producto_inicial = producto_lm
        tasa_interes_inicial = tasa_interes_is

    return producto_inicial, tasa_interes_inicial, tipo_cambio_inicial

curva_is = CurvaIS(-1, 0.05, 1, 0.05, 10)
curva_lm = CurvaLM(1, 1, 1, 0.05, 10)
curva_bp = CurvaBP(0.05, 1000, 100,1100)

producto_eq, tasa_interes_eq, tipo_cambio_eq = encontrar_equilibrio(curva_is, curva_lm, curva_bp)

print("Producto de equilibrio:", producto_eq)
print("Tasa de interés de equilibrio:", tasa_interes_eq)
print("Tipo de cambio de equilibrio:", tipo_cambio_eq)

"""#Simulaciones

*   La inteligencia: es la capacidad de ***aprender***
*   aprender: capacidad de reconocer patrones de la realidad
*   dato: es una pieza de información que describe algun aspecto del mundo
* modelo: es una representación simplificada de la realidad (función)
* En esta clase se va a buscar encontrar las funciones


---
"""

class CurvaIS:
    def __init__(self, pendiente, intercepto, multiplicador, tasa_interes, producto):
        self.pendiente = pendiente
        self.intercepto = intercepto
        self.multiplicador = multiplicador
        self.tasa_interes = tasa_interes
        self.producto = producto

    def calcular_tasa_interes_equilibrio(self, producto_nuevo):
        tasa_interes_nueva = (self.intercepto - producto_nuevo / self.multiplicador) / self.pendiente
        return tasa_interes_nueva

    def desplazar_curva(self, cambio_intercepto):
        self.intercepto += cambio_intercepto

class CurvaLM:
    def __init__(self, pendiente, intercepto, oferta_monetaria, tasa_interes, producto):
        self.pendiente = pendiente
        self.intercepto = intercepto
        self.oferta_monetaria = oferta_monetaria
        self.tasa_interes = tasa_interes
        self.producto = producto

    def calcular_producto_equilibrio(self, tasa_interes_nueva):
        producto_nuevo = (self.oferta_monetaria - self.intercepto - self.pendiente * tasa_interes_nueva) / self.pendiente
        return producto_nuevo

    def desplazar_curva(self, cambio_oferta_monetaria):
        self.oferta_monetaria += cambio_oferta_monetaria


class CurvaBP:
    def __init__(self, tasa_interes_mundial, tipo_cambio, balanza_comercial, flujo_capital):
        self.tasa_interes_mundial = tasa_interes_mundial
        self.tipo_cambio = tipo_cambio
        self.balanza_comercial = balanza_comercial
        self.flujo_capital = flujo_capital

    def calcular_tasa_interes_equilibrio(self):
        # En el modelo Mundell-Fleming con perfecta movilidad de capitales, la tasa de interés doméstica
        # debe igualarse a la tasa de interés mundial para que haya equilibrio en la balanza de pagos.
        tasa_interes_equilibrio = self.tasa_interes_mundial
        return tasa_interes_equilibrio

    def desplazar_curva(self, tipo_cambio_nuevo):
        # Un cambio en el tipo de cambio afecta la balanza comercial, desplazando la curva BP.
        self.tipo_cambio += tipo_cambio_nuevo

    def actualizar_tipo_cambio(self, tasa_interes_is, producto_lm, tipo_cambio_actual):
        # Implementación simplificada para actualizar el tipo de cambio basado en el producto y la tasa de interés.
        tipo_cambio_nuevo = (tasa_interes_is - producto_lm / 1000) * 0.01
        return tipo_cambio_actual + tipo_cambio_nuevo




def encontrar_equilibrio(CurvaIS, CurvaLM, CurvaBP, max_iteraciones=100):
    producto_inicial = CurvaIS.producto
    tasa_interes_inicial = CurvaLM.tasa_interes
    tipo_cambio_inicial = CurvaBP.tipo_cambio

    for _ in range(max_iteraciones):
        tasa_interes_is = CurvaIS.calcular_tasa_interes_equilibrio(producto_inicial)
        producto_lm = CurvaLM.calcular_producto_equilibrio(tasa_interes_inicial)
        tasa_interes_bp = CurvaBP.calcular_tasa_interes_equilibrio()

        # Verificamos si las diferencias son muy pequeñas
        if abs(tasa_interes_is - tasa_interes_inicial) < 1e-10 and \
           abs(producto_lm - producto_inicial) < 1e-10 and \
           abs(tasa_interes_is - tasa_interes_bp) < 1e-10:
            break

        tipo_cambio_inicial = CurvaBP.actualizar_tipo_cambio(tasa_interes_is, producto_lm, tipo_cambio_inicial)

        producto_inicial = producto_lm
        tasa_interes_inicial = tasa_interes_is

    return producto_inicial, tasa_interes_inicial, tipo_cambio_inicial




curva_is = CurvaIS(-1, 0.05, 1, 0.05, 10)
curva_lm = CurvaLM(1, 1, 1, 0.05, 10)
curva_bp = CurvaBP(0.05, 1000, 100,1100)

producto_eq, tasa_interes_eq, tipo_cambio_eq = encontrar_equilibrio(curva_is, curva_lm, curva_bp)

print("Producto de equilibrio:", producto_eq)
print("Tasa de interés de equilibrio:", tasa_interes_eq)
print("Tipo de cambio de equilibrio:", tipo_cambio_eq)

"""class CurvaIS:
    def __init__(self, pendiente, intercepto, multiplicador, tasa_interes, producto):

 class CurvaLM:
    def __init__(self, pendiente, intercepto, oferta_monetaria, tasa_interes, producto):

class CurvaBP:
    def __init__(self, tasa_interes_mundial, tipo_cambio, balanza_comercial, flujo_capital):       
"""